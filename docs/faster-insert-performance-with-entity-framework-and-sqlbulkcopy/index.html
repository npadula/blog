<!DOCTYPE html>
<html lang="en">
<head>
	<title>Faster Insert Performance with Entity Framework and SqlBulkCopy &middot; Nicolas Padula</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<link rel="stylesheet" href="/blog/style.css"/>
</head>
<body>
	<nav><a href="https://npadula.github.io/blog"><img src="/blog/home.svg"></a></nav>
	
<main class=single>
	<header>
		<div id=sitetitle>Nicolas Padula:</div>
		<h1>Faster Insert Performance with Entity Framework and SqlBulkCopy</h1>
		<time>7 Apr 2020</time>
		<div id=description>Faster Insert Performance with Entity Framework and SqlBulkCopy</div>
	</header>
	<article class=single>
		<aside id=toc>
			<nav id="TableOfContents"></nav>
		</aside>
		<span id=dropcap></span><p>While Entity Framework is a great ORM tool, sometimes it falls short of the desired performance in operations involving large quantities of inserts. Since EF doesn&rsquo;t support batch operations, the best approach in these cases is to do batch insert manually.</p>
<p>SqlBulkCopy provides a straightforward way to do this. All you have to do is build a DataTable out of the entities you want to insert, pass it to SqlBulkCopy and it&rsquo;s done.</p>
<p>However, in a real world application your persistence logic will probably involve a more complex scenario, and you will have to mix EF and batch logic in the same transaction.</p>
<p>At work, I recently encountered a situation where I had to delete some records, insert some parent records, and then batch insert many child records, and it all needed to be wrapped in the same transaction in case something went wrong in the middle.</p>
<pre><code class="language-aspnet" data-lang="aspnet">    public void SaveEntities(IEnumerable&lt;MyEntity&gt; entities, IEnumerable&lt;MyEntity&gt; entitiesToDelete)
            {
    			//this.dataContext is injected via DI, so we use it's connection string to open a new, different connection
                var connectionString = this.dataContext.Database.Connection.ConnectionString;
                var connection = (SqlConnection)this.dataContext.Database.Connection;
                var workspace = ((IObjectContextAdapter)this.dataContext).ObjectContext.MetadataWorkspace;
                var entityConnection = new EntityConnection(workspace, connection);
    
    			//Wrap everything inside a transaction
                using (var scope = Helpers.CreateTransactionScope())
                {
                    try
                    {
    
    
                        if (connection.State == ConnectionState.Closed)
                            connection.Open();
    
    					//Since this.dataContext is injected via DI, we cannot use that instance because it already owns a connection
    					//so we create a new instance and pass it an existing connection
                        var bulkContext = new MyDataContext(entityConnection); //Not the same as this.dataContext !!
    
    					
    					//Delete records
                        if(entitiesToDelete != null)
                        {
                            foreach (var a in entitiesToDelete)
                                bulkContext.MyEntities.Remove(a);
                        }
                        bulkContext.SaveChanges();
    
    						
                            foreach (var e in entities)
                            {
    							//Pass the connection used for bulkContext to SqlBulkCopy
                                var sqlBulkCopy = new SqlBulkCopy(connection);
    							/*
    								Do some stuff and insert some parent records
    							*/
    							
                                bulkContext.SaveChanges();
    
    
    
    
                                DataTable table = Helpers.BuildTable(aptusFromAssignment);
    
    
    
                                sqlBulkCopy.DestinationTableName = &quot;MyEntitiesTable&quot;;
                                sqlBulkCopy.ColumnMappings.Add(&quot;SomeId&quot;, &quot;SomeId&quot;);
                                sqlBulkCopy.ColumnMappings.Add(&quot;SomeValue&quot;, &quot;SomeValue&quot;);
    
                                sqlBulkCopy.WriteToServer(table);
                            }
    
                        
    										//Commit transaction and close connection
                        scope.Complete();
                        connection.Close();
                    }
                    catch (Exception ex)
                    {
                        connection.Close();
                        throw ex;
                    }
                }
    
            }
</code></pre><p>Note that, while we are passing the same connection to the EF context and SqlBulkCopy, EF Context needs the connection to be an EntityConnection, while SqlBulkCopy just needs a plain SqlConnection.</p>
<p>The methods for building the table and creating the transaction scope are here:</p>
<pre><code>    public class Helpers
        {
    				//Takes a collection of entities and build the datatable that will be inserted
            public static DataTable BuildTable(ICollection&lt;MyEntity&gt; entities)
            {
                var result = new DataTable();
    
    						//Set up the appropiate columns of the table
                result.Columns.Add(&quot;SomeId&quot;, typeof(int));
                result.Columns.Add(&quot;SomeValue&quot;, typeof(decimal));
    
    
                foreach (var e in entities)
                {
                    result.Rows.Add(e.SomeId, e.SomeValue);
                }
    
    
                return result;
            }
    
    
            public static TransactionScope CreateTransactionScope()
            {
                var transactionOptions = new TransactionOptions();
                transactionOptions.IsolationLevel = System.Transactions.IsolationLevel.ReadCommitted;
                transactionOptions.Timeout = TransactionManager.MaximumTimeout;
                return new TransactionScope(TransactionScopeOption.Required, transactionOptions);
            }
        }
        ```</code></pre>
	</article>
</main>

</body>
</html>